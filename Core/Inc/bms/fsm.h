/******************************************************************************
Finite State Machine
Project: mainboard_fsm
Description: Main mainboard FSM that handles all the operations of the BMS

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.3
Generation date: 2024-07-10 00:34:18 +0200
Generated from: fsm.dot
The finite state machine has:
  9 states
  11 transition functions
Functions and types have been generated with prefix "fsm_"
******************************************************************************/

#ifndef FSM_H
#define FSM_H
#include <stdlib.h>
#include <stdbool.h>

/*** USER CODE BEGIN MACROS ***/
#include <stddef.h>

#include "bms_network.h"
#include "primary_network.h"

// TODO: Define feedback masks and expected values

/**
 * @brief Definition of the possible events types
 *
 * @details The FSM_EVENT_TYPE_IGNORED should only be used for initialization purposes
 * and it is not counted as part of the other events
 *
 * @details
 *     - FSM_EVENT_TYPE_FLASH_REQUEST the request for the start of a flash procedure
 *     - FSM_EVENT_TYPE_TS_ON request for the TS on
 *     - FSM_EVENT_TYPE_TS_OFF request for the TS off
 *     - FSM_EVENT_TYPE_AIRN_TIMEOUT the AIR- watchdog has timed out
 *     - FSM_EVENT_TYPE_PRECHARGE_TIMEOUT the precharge watchdog has timed out
 *     - FSM_EVENT_TYPE_AIRP_TIMEOUT the AIR+ watchdog has timed out
 *     - FSM_EVENT_TYPE_IGNORED event that should be ignored
 */
typedef enum {
    FSM_EVENT_TYPE_FLASH_REQUEST,
    FSM_EVENT_TYPE_TS_ON,
    FSM_EVENT_TYPE_TS_OFF,
    FSM_EVENT_TYPE_AIRN_TIMEOUT,
    FSM_EVENT_TYPE_PRECHARGE_TIMEOUT,
    FSM_EVENT_TYPE_AIRP_TIMEOUT,
    FSM_EVENT_TYPE_COUNT,
    FSM_EVENT_TYPE_IGNORED
} FsmEventType;
/*** USER CODE END MACROS ***/

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
/*** USER STATE DATA TYPE BEGIN ***/
typedef void fsm_state_data_t;
/*** USER STATE DATA TYPE END ***/
// Event data object
// By default the struct is empty; put the data of the event inside
// the structure if you need or leave it empty
typedef struct {
  
  /*** USER CODE BEGIN EVENT_DATA ***/
  FsmEventType type;
  /*** USER CODE END EVENT_DATA ***/

} fsm_event_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  FSM_STATE_INIT = 0,  
  FSM_STATE_IDLE,  
  FSM_STATE_FATAL,  
  FSM_STATE_FLASH,  
  FSM_STATE_BALANCING,  
  FSM_STATE_AIRN_CHECK,  
  FSM_STATE_PRECHARGE_CHECK,  
  FSM_STATE_AIRP_CHECK,  
  FSM_STATE_TS_ON,  
  FSM_NUM_STATES,
  FSM_NO_CHANGE
} fsm_state_t;

// State human-readable names
extern const char *fsm_state_names[];

// State function and state transition prototypes
typedef fsm_state_t state_func_t(fsm_state_data_t *data);
typedef void transition_func_t(fsm_state_data_t *data);

/*** USER CODE BEGIN TYPES ***/

/*** USER CODE END TYPES ***/

// Functions to check and trigger an event
bool fsm_is_event_triggered();
void fsm_event_trigger(fsm_event_data_t *event);

// State functions

// Function to be executed in state init
// valid return states: FSM_STATE_IDLE, FSM_STATE_FATAL
fsm_state_t fsm_do_init(fsm_state_data_t *data);

// Function to be executed in state idle
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_BALANCING, FSM_STATE_AIRN_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_idle(fsm_state_data_t *data);

// Function to be executed in state fatal
// valid return states: FSM_NO_CHANGE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_fatal(fsm_state_data_t *data);

// Function to be executed in state flash
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_flash(fsm_state_data_t *data);

// Function to be executed in state balancing
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_BALANCING, FSM_STATE_FATAL
fsm_state_t fsm_do_balancing(fsm_state_data_t *data);

// Function to be executed in state airn_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_AIRN_CHECK, FSM_STATE_PRECHARGE_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_airn_check(fsm_state_data_t *data);

// Function to be executed in state precharge_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_PRECHARGE_CHECK, FSM_STATE_AIRP_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_precharge_check(fsm_state_data_t *data);

// Function to be executed in state airp_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_AIRP_CHECK, FSM_STATE_TS_ON, FSM_STATE_FATAL
fsm_state_t fsm_do_airp_check(fsm_state_data_t *data);

// Function to be executed in state ts_on
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_TS_ON, FSM_STATE_FATAL
fsm_state_t fsm_do_ts_on(fsm_state_data_t *data);


// List of state functions
extern state_func_t *const fsm_state_table[FSM_NUM_STATES];


// Transition functions
void fsm_start(fsm_state_data_t *data);
void fsm_handle_fatal_error(fsm_state_data_t *data);
void fsm_start_flash_procedure(fsm_state_data_t *data);
void fsm_start_balancing(fsm_state_data_t *data);
void fsm_close_airn(fsm_state_data_t *data);
void fsm_stop_flash_procedure(fsm_state_data_t *data);
void fsm_stop_balancing(fsm_state_data_t *data);
void fsm_ts_off(fsm_state_data_t *data);
void fsm_start_precharge(fsm_state_data_t *data);
void fsm_close_airp(fsm_state_data_t *data);
void fsm_ts_on(fsm_state_data_t *data);

// Table of transition functions
extern transition_func_t *const fsm_transition_table[FSM_NUM_STATES][FSM_NUM_STATES];

// state manager
fsm_state_t fsm_run_state(fsm_state_t cur_state, fsm_state_data_t *data);

/*** USER CODE BEGIN FUNCTIONS ***/
/**
 * @brief Get the current status of the FSM
 *
 * @return fsm_state_t The FSM status
 */
fsm_state_t fsm_get_status(void);

/**
 * @brief Handle the received cellboard status
 *
 * @param payload A pointer to the canlib payload
 */
void fsm_cellboard_state_handle(bms_cellboard_status_converted_t * payload);

/**
 * @brief Get a pointer to the CAN payload structure of the FSM status
 *
 * @param byte_size[out] A pointer where the size of the payload in bytes is stored (can be NULL)
 *
 * @return primary_hv_status_converted_t* A pointer to the payload
 */
primary_hv_status_converted_t * fsm_get_can_payload(size_t * byte_size);
/*** USER CODE END FUNCTIONS ***/

#endif
