/******************************************************************************
Finite State Machine
Project: mainboard_fsm
Description: Main mainboard FSM that handles all the operations of the BMS

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.3
Generation date: 2024-06-19 22:28:14 +0200
Generated from: fsm.dot
The finite state machine has:
  9 states
  12 transition functions
Functions and types have been generated with prefix "fsm_"
******************************************************************************/

#include "fsm.h"

/*** USER CODE BEGIN MACROS ***/

#include <string.h>

#include "can-comm.h"
#include "timebase.h"
#include "programmer.h"

/*** USER CODE END MACROS ***/


// GLOBALS
// State human-readable names
const char *fsm_state_names[] = {"init", "idle", "fatal", "flash", "balancing", "airn_check", "precharge_check", "airp_check", "ts_on"};

// List of state functions
state_func_t *const fsm_state_table[FSM_NUM_STATES] = {
  fsm_do_init,            // in state init
  fsm_do_idle,            // in state idle
  fsm_do_fatal,           // in state fatal
  fsm_do_flash,           // in state flash
  fsm_do_balancing,       // in state balancing
  fsm_do_airn_check,      // in state airn_check
  fsm_do_precharge_check, // in state precharge_check
  fsm_do_airp_check,      // in state airp_check
  fsm_do_ts_on,           // in state ts_on
};

// Table of transition functions
transition_func_t *const fsm_transition_table[FSM_NUM_STATES][FSM_NUM_STATES] = {
  /* states:             init                     , idle                     , fatal                    , flash                    , balancing                , airn_check               , precharge_check          , airp_check               , ts_on                     */
  /* init            */ {NULL                     , fsm_start                , fsm_handler_fatal_error  , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* idle            */ {NULL                     , NULL                     , fsm_handler_fatal_error  , fsm_start_flash_procedure, fsm_start_balancing      , fsm_close_airn           , NULL                     , NULL                     , NULL                     }, 
  /* fatal           */ {NULL                     , NULL                     , NULL                     , fsm_start_flash_procedure, NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* flash           */ {NULL                     , fsm_stop_flash_procedure , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* balancing       */ {NULL                     , fsm_stop_balancing       , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* airn_check      */ {NULL                     , fsm_ts_off               , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , fsm_start_precharge      , NULL                     , NULL                     }, 
  /* precharge_check */ {NULL                     , fsm_ts_off               , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , NULL                     , fsm_close_airp           , NULL                     }, 
  /* airp_check      */ {NULL                     , fsm_ts_off               , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , fsm_ts_on                }, 
  /* ts_on           */ {NULL                     , fsm_ts_off               , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
};

// Triggered event
fsm_event_data_t * fsm_fired_event = NULL;

/*** USER CODE BEGIN GLOBALS ***/

static struct {
    fsm_state_t fsm_state;
    primary_hv_flash_response_converted_t flash_can_payload;
} hfsm = {
    .fsm_state = FSM_STATE_INIT
};

/*** USER CODE END GLOBALS ***/


// Function to check if an event has fired
inline bool fsm_is_event_triggered() {
    return fsm_fired_event != NULL;
}

// Function to trigger an event
inline void fsm_event_trigger(fsm_event_data_t *event) {
    if (fsm_fired_event != NULL)
        return;
    fsm_fired_event = event ? event : &(fsm_event_data_t){};
}


/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: FSM_STATE_IDLE, FSM_STATE_FATAL
fsm_state_t fsm_do_init(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_STATE_IDLE;
  
  
  /*** USER CODE BEGIN DO_INIT ***/

  // Initialize the FSM handler
  memset(&hfsm, 0U, sizeof(hfsm));
  hfsm.fsm_state = FSM_STATE_INIT;
  
  /*** USER CODE END DO_INIT ***/
  
  switch (next_state) {
    case FSM_STATE_IDLE:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_BALANCING, FSM_STATE_AIRN_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_idle(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_IDLE ***/
  (void)timebase_routine();

  if (fsm_is_event_triggered() && fsm_fired_event->type == FSM_EVENT_TYPE_FLASH_REQUEST)
      next_state = FSM_STATE_FLASH;
  /*** USER CODE END DO_IDLE ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_FLASH:
    case FSM_STATE_BALANCING:
    case FSM_STATE_AIRN_CHECK:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state fatal
// valid return states: FSM_NO_CHANGE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_fatal(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_FATAL ***/
  
  /*** USER CODE END DO_FATAL ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_FLASH:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flash
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_flash(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_FLASH ***/

  ProgrammerReturnCode code = programmer_routine();
  if (code == PROGRAMMER_TIMEOUT || code == PROGRAMMER_OK)
      next_state = FSM_STATE_IDLE;
  
  /*** USER CODE END DO_FLASH ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_FLASH:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state balancing
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_BALANCING, FSM_STATE_FATAL
fsm_state_t fsm_do_balancing(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_BALANCING ***/
  
  /*** USER CODE END DO_BALANCING ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_BALANCING:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state airn_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_AIRN_CHECK, FSM_STATE_PRECHARGE_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_airn_check(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_AIRN_CHECK ***/
  
  /*** USER CODE END DO_AIRN_CHECK ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_AIRN_CHECK:
    case FSM_STATE_PRECHARGE_CHECK:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state precharge_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_PRECHARGE_CHECK, FSM_STATE_AIRP_CHECK, FSM_STATE_FATAL
fsm_state_t fsm_do_precharge_check(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_PRECHARGE_CHECK ***/
  
  /*** USER CODE END DO_PRECHARGE_CHECK ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_PRECHARGE_CHECK:
    case FSM_STATE_AIRP_CHECK:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state airp_check
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_AIRP_CHECK, FSM_STATE_TS_ON, FSM_STATE_FATAL
fsm_state_t fsm_do_airp_check(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_AIRP_CHECK ***/
  
  /*** USER CODE END DO_AIRP_CHECK ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_AIRP_CHECK:
    case FSM_STATE_TS_ON:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state ts_on
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_TS_ON, FSM_STATE_FATAL
fsm_state_t fsm_do_ts_on(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_TS_ON ***/
  
  /*** USER CODE END DO_TS_ON ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_TS_ON:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 1 transition:
// 1. from init to idle
void fsm_start(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START ***/
  can_comm_enable_all();
  timebase_set_enable(true);  
  /*** USER CODE END START ***/
}

// This function is called in 2 transitions:
// 1. from init to fatal
// 2. from idle to fatal
void fsm_handler_fatal_error(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN HANDLER_FATAL_ERROR ***/
  
  /*** USER CODE END HANDLER_FATAL_ERROR ***/
}

// This function is called in 2 transitions:
// 1. from idle to flash
// 2. from fatal to flash
void fsm_start_flash_procedure(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_FLASH_PROCEDURE ***/ 

  /*** USER CODE END START_FLASH_PROCEDURE ***/
}

// This function is called in 1 transition:
// 1. from idle to balancing
void fsm_start_balancing(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_BALANCING ***/
  
  /*** USER CODE END START_BALANCING ***/
}

// This function is called in 1 transition:
// 1. from idle to airn_check
void fsm_close_airn(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN CLOSE_AIRN ***/
  
  /*** USER CODE END CLOSE_AIRN ***/
}

// This function is called in 1 transition:
// 1. from flash to idle
void fsm_stop_flash_procedure(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN STOP_FLASH_PROCEDURE ***/
  
  /*** USER CODE END STOP_FLASH_PROCEDURE ***/
}

// This function is called in 6 transitions:
// 1. from flash to fatal
// 2. from balancing to fatal
// 3. from airn_check to fatal
// 4. from precharge_check to fatal
// 5. from airp_check to fatal
// 6. from ts_on to fatal
void fsm_handle_fatal_error(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN HANDLE_FATAL_ERROR ***/
  
  /*** USER CODE END HANDLE_FATAL_ERROR ***/
}

// This function is called in 1 transition:
// 1. from balancing to idle
void fsm_stop_balancing(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN STOP_BALANCING ***/
  
  /*** USER CODE END STOP_BALANCING ***/
}

// This function is called in 4 transitions:
// 1. from airn_check to idle
// 2. from precharge_check to idle
// 3. from airp_check to idle
// 4. from ts_on to idle
void fsm_ts_off(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN TS_OFF ***/
  
  /*** USER CODE END TS_OFF ***/
}

// This function is called in 1 transition:
// 1. from airn_check to precharge_check
void fsm_start_precharge(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_PRECHARGE ***/
  
  /*** USER CODE END START_PRECHARGE ***/
}

// This function is called in 1 transition:
// 1. from precharge_check to airp_check
void fsm_close_airp(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN CLOSE_AIRP ***/
  
  /*** USER CODE END CLOSE_AIRP ***/
}

// This function is called in 1 transition:
// 1. from airp_check to ts_on
void fsm_ts_on(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN TS_ON ***/
  
  /*** USER CODE END TS_ON ***/
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

fsm_state_t fsm_run_state(fsm_state_t cur_state, fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN RUN_STATE ***/
  
  /*** USER CODE END RUN_STATE ***/

  fsm_event_data_t *prev_ev = fsm_fired_event;
  fsm_state_t new_state = fsm_state_table[cur_state](data);
  // Reset event status
  if (prev_ev != NULL)
    fsm_fired_event = NULL;
  if (new_state == FSM_NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = fsm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

/*** USER CODE BEGIN FUNCTIONS ***/

fsm_state_t fsm_get_status(void) {
    return hfsm.fsm_state;
}

/*** USER CODE END FUNCTIONS ***/

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  fsm_state_t cur_state = FSM_STATE_INIT;
  do {
    cur_state = fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (1);
  return 0;
}
#endif
